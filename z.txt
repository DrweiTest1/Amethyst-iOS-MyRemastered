在 iOS 平台上，若要替换  libarchive  实现 JAR/ZIP 压缩包读取功能，优先推荐使用第三方库  SSZipArchive ——它基于 Apple 原生  zlib  封装，体积轻量、集成简单，且无需依赖系统外库（如  libarchive ），能完美覆盖  ModService.m  中“读取压缩包内指定文件”的核心需求。以下是具体替换方案：
 
一、替换核心思路
 
原代码中  readFileFromJar:entryName:  方法依赖  libarchive  实现“遍历 ZIP 条目 + 读取指定文件数据”，替换后将通过  SSZipArchive  的枚举接口遍历压缩包条目，找到目标文件后直接读取其数据，逻辑完全对齐原功能，且无需修改其他依赖该方法的上层逻辑（如元数据解析、图标提取）。
 
二、具体实施步骤
 
1. 集成  SSZipArchive  库
 
 SSZipArchive  支持通过 CocoaPods 或手动导入，推荐用 CocoaPods 简化集成：
 
- 步骤1：在项目的  Podfile  中添加依赖（若没有  Podfile ，需先执行  pod init  创建）：
platform :ios, '14.0'  # 与项目部署目标一致
target 'AmethystMods' do  # 替换为你的 Target 名称
  pod 'SSZipArchive', '~> 2.0'  # 使用最新稳定版
end
 
- 步骤2：执行安装命令，自动下载并集成库：
pod install --repo-update
 
- 手动导入（备选）：若不使用 CocoaPods，可从 SSZipArchive 官网 下载源码，将  SSZipArchive.h 、 SSZipArchive.m  及  minizip  目录（依赖的 zlib 封装）拖入项目，确保勾选“Add to targets”。
 
2. 修改  ModService.m  代码
 
核心是替换  readFileFromJar:entryName:  方法（删除  libarchive  相关代码，改用  SSZipArchive  接口），其他方法无需改动。
 
（1）删除  libarchive  相关依赖
 
删除文件头部的  libarchive  头文件引入：
 
// 删掉这两行
#include <archive.h>
#include <archive_entry.h>
 
 
（2）导入  SSZipArchive  头文件
 
在文件头部添加  SSZipArchive  引入：
 
#import "SSZipArchive.h"
 
 
（3）重写  readFileFromJar:entryName:  方法
 
用  SSZipArchive  的  enumerateEntriesInZipFileAtPath:usingBlock:  枚举压缩包条目，匹配目标文件后读取数据，逻辑与原代码完全对齐（支持路径归一化、大小写不敏感、basename匹配）：
 
#pragma mark - Read specific entry from jar (SSZipArchive 替换 libarchive)
- (NSData *)readFileFromJar:(NSString *)jarPath entryName:(NSString *)entryName {
    if (!jarPath || !entryName || ![[NSFileManager defaultManager] fileExistsAtPath:jarPath]) {
        return nil;
    }
    
    __block NSData *targetFileData = nil;  // 存储目标文件数据
    __block BOOL found = NO;  // 标记是否找到目标条目
    
    // 枚举 ZIP/JAR 包内所有条目
    [SSZipArchive enumerateEntriesInZipFileAtPath:jarPath usingBlock:^(NSString * _Nonnull entryPath, zipped_file_info _Nonnull zipInfo, BOOL * _Nonnull stop) {
        if (found) {
            *stop = YES;  // 找到后终止枚举，提升效率
            return;
        }
        
        // 1. 归一化路径（统一替换 \ 为 /，与原代码逻辑一致）
        NSString *normalizedEntryPath = [entryPath stringByReplacingOccurrencesOfString:@"\\" withString:@"/"];
        NSString *normalizedTargetName = [entryName stringByReplacingOccurrencesOfString:@"\\" withString:@"/"];
        
        // 2. 匹配逻辑（完全对齐原代码：精确匹配、basename匹配、大小写不敏感匹配）
        BOOL isMatch = 
            [normalizedEntryPath isEqualToString:normalizedTargetName] ||  // 精确路径匹配
            [[normalizedEntryPath lastPathComponent] isEqualToString:normalizedTargetName] ||  // basename 匹配
            ([normalizedEntryPath caseInsensitiveCompare:normalizedTargetName] == NSOrderedSame);  // 大小写不敏感匹配
        
        if (isMatch) {
            // 3. 读取目标条目数据（SSZipArchive 直接提供读取单个条目数据的接口）
            targetFileData = [SSZipArchive dataForEntryAtPath:normalizedEntryPath inZipFileAtPath:jarPath];
            found = YES;
            *stop = YES;  // 终止后续枚举
        }
    } error:NULL];  // 若需处理枚举错误，可传入 NSError** 参数
    
    return targetFileData;
}
 
 
3. 验证替换效果
 
1. 重新构建项目：由于已移除  libarchive  依赖，无需再配置其头文件和库路径，直接执行原构建命令（ gmake ... ）即可，编译器不会再报  archive.h  未找到错误。
2. 功能验证：
- 测试  fetchMetadataForMod:completion:  能否正常读取 Mod JAR 内的  fabric.mod.json 、 mods.toml  等元数据；
- 测试  extractFirstMatchingImageFromJar:candidates:baseName:  能否正常提取 Mod 图标并缓存；
- 确保 Mod 扫描、启用/禁用等上层功能不受影响。
 
三、方案优势与注意事项
 
1. 优势
 
- 无额外系统依赖： SSZipArchive  仅依赖 iOS 系统自带的  zlib （无需安装  libarchive ），避免构建环境配置问题；
- API 简洁：无需手动管理  archive  实例、内存缓冲区， SSZipArchive  已封装好枚举、读取、解压等接口，代码量减少 50% 以上；
- 稳定性高： SSZipArchive  是 iOS 生态常用库（GitHub 20k+ Star），支持 ZIP 加密、大文件处理，兼容性优于自定义实现；
- 无需修改上层逻辑：仅替换  readFileFromJar:entryName:  一个方法，其他功能（如元数据解析、Mod 管理）完全复用原有代码，低侵入性。
 
2. 注意事项
 
- 库版本兼容：确保  SSZipArchive  版本与项目部署目标（iOS 14.0）匹配，推荐使用 2.0+ 版本；
- 错误处理增强：若需更严谨的错误处理，可在  enumerateEntriesInZipFileAtPath:usingBlock:error:  中传入  NSError** ，捕获枚举失败（如文件损坏、不支持的压缩格式）；
- 许可证合规： SSZipArchive  使用 MIT 许可证，可自由用于商业或开源项目，无需额外授权。
 
四、备选方案（无第三方库，纯原生）
 
若不希望引入第三方库，可基于 iOS 原生  NSFileManager  +  zlib  手动实现，但需自己处理 ZIP 格式解析（如文件头、CRC 校验、压缩数据解压），代码复杂度极高（需数百行），且易出现兼容性问题（如不支持 ZIP64、分卷压缩），仅推荐在特殊场景下使用。核心思路是：
 
1. 通过  NSFileHandle  读取 JAR/ZIP 文件的中央目录（Central Directory），解析出每个条目的路径、偏移量、压缩大小；
2. 定位目标条目的数据区，读取压缩数据；
3. 用  zlib  的  inflateInit2() 、 inflate()  接口解压数据，得到原始文件内容。
 
但该方案实现成本高、维护困难，远不如  SSZipArchive  高效，因此优先推荐前者。
